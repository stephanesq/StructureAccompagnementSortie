---
title: "Eligibiliték"
output: html_notebook
---

# Outputs
- Liste des éligibles à la LSC à la date de leur première éligibilité
- Liste des écroués en AP au moment des 2/3 de leur peine et éligibles à la LSC s'ils ne bénéficiaient pas déjà d'une AP

# ORGANISATION
- Informations sur :
  - Date écrou initial
  - Date de libération + motif si LC

- Situ pénale
  - Conserver que 
    - situ pénale avant libération OU si LC avant date de libération prévisionnelle
  - On fait un premier traitement pour déterminer les périodes pendant lesquelles la personne est éligible à la LSC en fonction du QTM, de la catégorie pénale et des 2/3 de la date de libération prev
  - On réunit ces périodes, peu importe la date des 2/3 elle-même

## Librairies

```{r librairies, include = FALSE}
# Import des librairies nécessaires 
# library(readxl)
# library(lubridate)
# library(stringi)
# library(fuzzyjoin)
# library(writexl) 
pacman::p_load(tidyverse, arrow, data.table, janitor, haven)

```

#0. Import des bases LSC + ref

###0.1 Chemin

```{r, warning=FALSE}
path = paste0(here::here(),"/Donnees/")
path_dwh = "~/Documents/Recherche/3_Evaluation/_DATA/INFPENIT/"
path_ref = "~/Documents/Recherche/3_Evaluation/_DATA/Referentiel/"
```

###0.2 Base de travail


##### Situation pénale

Réflexions :
- Problème de déperdition info date de lib prévisionnelle avant 2016
- Mais utilisation IP sans filtre source = pb -> 6 x plus de lignes

```{r}
# Établir la connexion aux données
t_dwh_h_situ_penale <- open_dataset(paste0(path_dwh,"t_dwh_h_situ_penale.parquet"))

t_dwh_h_situ_penale <- t_dwh_h_situ_penale |>
  # Définir la requête
  # Filtre et selection
  filter(TP_SOURCE == "GENESIS") |>
  select(NM_ECROU_INIT, DT_DEBUT_SITU_PENALE, DT_FIN_SITU_PENALE, 
         CD_CP_GLOBALE, CD_CP_GLO_MAN, CD_CP_DETAIL, DT_LIBE_PREV, 
         QTM_FERME_TACC_A, QTM_FERME_TACC_M, QTM_FERME_TACC_S, QTM_FERME_TACC_J) |>
  filter(!is.na(DT_LIBE_PREV))  |>  #sinon inutile
# Récupérer le résultat sous forme d'un data.frame
  collect()

# changement des formats
t_dwh_h_situ_penale <- t_dwh_h_situ_penale |>
  mutate_at(vars(starts_with("DT_")), as.Date) |>
  mutate_at(vars(starts_with("QTM_")), as.numeric)

#modif quantum + date situ penale
t_dwh_h_situ_penale <- t_dwh_h_situ_penale |>
  # Quantum ferme
  mutate(QTM_FERME_TACC = QTM_FERME_TACC_A * 360 + QTM_FERME_TACC_M *30 + QTM_FERME_TACC_S *7 + QTM_FERME_TACC_J) |>
  select(-QTM_FERME_TACC_A, -QTM_FERME_TACC_M, -QTM_FERME_TACC_S, -QTM_FERME_TACC_J)|>
  #garder date fin en date début
  arrange(NM_ECROU_INIT, DT_DEBUT_SITU_PENALE) |>
  group_by(NM_ECROU_INIT) |>
  mutate(DT_SITU_PENALE = lag(DT_FIN_SITU_PENALE, default = first(DT_DEBUT_SITU_PENALE, na.rm = TRUE))) |>
  ungroup() |>
    # on enlève les dates inutiles
    select(-DT_FIN_SITU_PENALE,-DT_DEBUT_SITU_PENALE)
# gc()
```

##### Date écrou initial

```{r}
t_dwh_ecrou_init <- open_dataset(paste0(path_dwh,"t_dwh_ecrou_init.parquet"))

t_dwh_ecrou_init <- t_dwh_ecrou_init |>
  select(NM_ECROU_INIT, DT_ECROU_INITIAL) |>
  collect()

t_dwh_ecrou_init <- t_dwh_ecrou_init %>% 
  mutate(DT_ECROU_INITIAL=as.Date(DT_ECROU_INITIAL)) %>% 
    distinct() 

```

##### Date de libération

```{r}

t_dwh_f_mouvement <- read_parquet(paste0(path_dwh,"t_dwh_f_mouvement.parquet"))

t_dwh_f_mouvement <- t_dwh_f_mouvement|>
  filter(TP_SOURCE ==  "GENESIS") |>
  filter(CD_TYPE_MOUVEMENT == "LIB" & CD_NATURE_MOUVEMENT == "LEVECR") |>
  select(NM_ECROU_INIT, DT_MOUVEMENT_REEL,CD_MOTIF_MOUVEMENT) |>
  collect()

t_dwh_f_mouvement <- t_dwh_f_mouvement %>% 
  group_by(NM_ECROU_INIT) %>%
  mutate(DT_LEVEECR = max(DT_MOUVEMENT_REEL)) %>%
  ungroup()  %>% 
    filter(DT_LEVEECR==DT_MOUVEMENT_REEL) %>% 
    mutate(DT_LEVEECR=as.Date(DT_LEVEECR),
           LEVEECR_LC=if_else(str_detect(CD_MOTIF_MOUVEMENT, "^LC") & CD_MOTIF_MOUVEMENT != 'LCTRT',1,0)) %>% 
  select(-DT_MOUVEMENT_REEL)

gc()
```

### Ajout info

##### Rplace FIN par DT_LEVEECR si existe OU LC

Pour les LC : Date de levée d'écrou LC +1 
- Redressement plus simple qu'un travail selon la date de situation pénale
- et on fait durer les LC jusqu'au lendemain du mouvement (j'imagine que selon les JAP ou les établissements, ils considèrent que la mesure devient effective le lendemain ?)
- un certain nombre de cas concernés
- 

```{r}

t_dwh_h_situ_penale_copie <- t_dwh_h_situ_penale %>% 
  left_join(t_dwh_f_mouvement) %>% 
  mutate(
    DT_FIN_SITU_PENALE = case_when(
    is.na(DT_LEVEECR) ~ DT_FIN_SITU_PENALE,
    DT_FIN_SITU_PENALE < DT_LEVEECR ~ DT_FIN_SITU_PENALE,
    LEVEECR_LC==1  ~ DT_LEVEECR+1,
    TRUE ~  DT_LEVEECR)) %>% 
  filter(DT_DEBUT_SITU_PENALE <= DT_FIN_SITU_PENALE)  


# t_dwh_h_situ_penale_copie <- t_dwh_h_situ_penale_copie %>%
#   mutate(
#     DT_FIN_SITU_PENALE2 = case_when(
#     is.na(DT_LEVEECR)|DT_FIN_SITU_PENALE<DT_LEVEECR ~ DT_FIN_SITU_PENALE,
#     LEVEECR_LC==1  ~ DT_LEVEECR+1,
#     TRUE ~  DT_LEVEECR))

rm(t_dwh_f_mouvement)
gc()
```

##### + date écrou initiale

```{r}
# Conserver lignes avec Eligibilité LSC (hors AP)
t_dwh_h_situ_penale <- t_dwh_h_situ_penale_copie %>% 
  # Date écrou initial
  left_join(t_dwh_ecrou_init)

rm(t_dwh_ecrou_init)
```


#1. Eligibilité (situ pénale)

1. Théorique
2. En vérifiant situation pént (AP)

###1.1 Retraitement et nettoyage des lignes

##### Table IP à Eligibles LSC

- Pour l'éligibilité des LSC, on a besoin du quantum ferme total, de la catégorie pénale et de la date de libération pévisionnelle
- On ne conserve que 
  - les personnes condamnées (dont CP)
  - les observations avec une date de libération prévisionnelle
  - et les lignes où il y a un changement de date de libération
- A NOTER
 - Code simplifie, on ne prend pas en compte un éventuel changement du quantum ferme qui n'aurait pas d'impact sur la date de lib prev (peu probable) 
 - Pour gérer les intervalles de situ pénal "identiques" (eligible LSC, dates qui se suivent, même date d'éligibilité), création de compteur
 - ATTENTION sur 2/3 peine, il faut prendre la valeur entière, sinon il y a des décimales cachées ...

```{r}
t_dwh_h_situ_penale <- t_dwh_h_situ_penale%>% 

  # Redressement catégorie pénale
# /!\ par rapport aux règles de gestion je n'ai pris que la première partie qui ne travaille que sur situ_penale et pas la partie sur la table mouvement parce que ça récupère toutes mes lignes sauf 3 que je mets en "CO" 
  mutate(CD_CP_REDR = as.factor(case_when(	
    ! CD_CP_GLOBALE %in% c('(ND)', '-', '') ~ as.character(CD_CP_GLOBALE),
    ! CD_CP_GLO_MAN %in% c('(ND)', '-', '') ~ as.character(CD_CP_GLO_MAN),
    CD_CP_DETAIL %in% c("PR", "PRE", "PRV", "APP", "DAP", "DPO", "OPP", "POU") ~ "PR",
    TRUE ~ "CO"))) %>% 
  select(-CD_CP_GLOBALE, -CD_CP_GLO_MAN, -CD_CP_DETAIL)

# Conserver lignes avec Eligibilité LSC (hors AP)
t_dwh_h_situ_penale <- t_dwh_h_situ_penale %>% 
  # Personnes condamnées avec date de libé prev
  filter(CD_CP_REDR != 'PR' & !is.na(DT_LIBE_PREV))  %>% 
  # Calcul 2/3 de peine
  mutate(DT_DEUXTIERSDEPEINE =  floor_date(time_length(difftime(DT_LIBE_PREV,DT_ECROU_INITIAL), "days")*2/3+DT_ECROU_INITIAL, unit = "day"),
         ERREUR =  time_length(difftime(DT_FIN_SITU_PENALE,DT_DEUXTIERSDEPEINE), "days"),
         ELIGIBLE = if_else(DT_DEUXTIERSDEPEINE <= (DT_FIN_SITU_PENALE) , 1, 0), #borne fermé pour les sorties LC
         ELIGIBLE_LSC = if_else(QTM_FERME_TACC/360 <= 5 & ELIGIBLE==1, 1, 0)
  ) %>% 
  filter(ELIGIBLE_LSC==1) 

# Réduire le nombre de lignes
t_dwh_h_situ_penale <- t_dwh_h_situ_penale %>% 
  # on récupère les dates de libe prev précedentes (voir si changement)
  ## si pas de changement
  ## si fin situ pénal = début celle précédente
  arrange(NM_ECROU_INIT, DT_DEBUT_SITU_PENALE) %>% 
  group_by(NM_ECROU_INIT) %>% 
  mutate(DT_LIBE_PREV_PREV = lag(DT_LIBE_PREV),
         DT_FIN_PREV = lag(DT_FIN_SITU_PENALE)+1,
         MM_SITU = if_else(is.na(DT_FIN_PREV)|DT_FIN_PREV!=DT_DEBUT_SITU_PENALE,1,0),
         MODIF_DT_LIBE = if_else(is.na(DT_LIBE_PREV_PREV)|DT_LIBE_PREV !=DT_LIBE_PREV_PREV,1,0),
         MODIF_ELIG=if_else(MM_SITU==0 & MODIF_DT_LIBE==0,0,1),
         ID_MODIF_DT_LIBE = cumsum(MODIF_ELIG)) %>% 
  ungroup() %>% 
  # Enlever variables inutiles
  select(-CD_CP_REDR,-ELIGIBLE,-DT_LIBE_PREV_PREV,-DT_FIN_PREV,-MM_SITU,-MODIF_DT_LIBE)

#Conserver que les lignes utiles
t_dwh_h_situ_penale <- t_dwh_h_situ_penale %>% 
  #garde qu'une ligne par enchaînement de situ pénit AP
  group_by(NM_ECROU_INIT,ID_MODIF_DT_LIBE) %>% 
  mutate(DT_FIN_SITU_PENALE = max(DT_FIN_SITU_PENALE)) %>% 
  ungroup() %>% 
  # selection des lignes avec changements  uniquement
  filter(MODIF_ELIG==1) %>% 
  # TRI  
  arrange(NM_ECROU_INIT, DT_DEBUT_SITU_PENALE)


# Eligible
ELIG_situ_penale <- t_dwh_h_situ_penale %>% 
  select(NM_ECROU_INIT,DT_DEBUT_SITU_PENALE,DT_DEUXTIERSDEPEINE,DT_FIN_SITU_PENALE, DT_LIBE_PREV, LEVEECR_LC,DT_LEVEECR) %>% 
  mutate(DT_DEBUT_DEUXTIERS = if_else(DT_DEUXTIERSDEPEINE <= DT_DEBUT_SITU_PENALE, DT_DEBUT_SITU_PENALE, DT_DEUXTIERSDEPEINE),
         DBT_AVANT = if_else(DT_DEUXTIERSDEPEINE <= DT_DEBUT_SITU_PENALE, 1,0)) %>% 
  # filter(year(DT_DEBUT_DEUXTIERS) >= 2014|year(DT_FIN_SITU_PENALE) >= 2014) %>% 
  arrange(NM_ECROU_INIT, DT_DEBUT_SITU_PENALE)
  

# Ecrous éligible
ECROU_ELIG <- ELIG_situ_penale %>% select(NM_ECROU_INIT) %>% distinct()

#rm(t_dwh_h_situ_penale)
```

##### Simplification des lignes
- récupérer date de fin de ligne précédente et comparer info
- Ici on se moque de la date de libération prévisionnelle
-> possible de simplifier probablement

```{r}
ELIG_situ_penale <- ELIG_situ_penale %>% 
  arrange(NM_ECROU_INIT,DT_DEBUT_DEUXTIERS) %>% 
  group_by(NM_ECROU_INIT) %>% 
  mutate(DT_FIN_PREV = lag(DT_FIN_SITU_PENALE)+1,
         MM_SITU = if_else(is.na(DT_FIN_PREV)|DT_FIN_PREV!=DT_DEBUT_DEUXTIERS,1,0),
         ID_SITU = cumsum(MM_SITU)) %>% 
  ungroup() %>% 
  #garde qu'une ligne par enchaînement de situ pénit AP
    group_by(NM_ECROU_INIT,ID_SITU) %>% 
    mutate(DT_FIN_SITU_PENALE = max(DT_FIN_SITU_PENALE)) %>% 
    ungroup() %>% 
      filter(MM_SITU==1) %>% 
  #selection des variables
  select(NM_ECROU_INIT,DT_DEUXTIERSDEPEINE,DT_DEBUT_DEUXTIERS,DT_FIN_SITU_PENALE, DT_LIBE_PREV, LEVEECR_LC,DT_LEVEECR) 

```


##### Export intermédiaire
```{r}
write_parquet(ELIG_situ_penale,paste0(path,"Export/ELIG_situ_penale.parquet"))

```

###1.2 LC - 2/3 de peine

- Ne conserver que le premier spell -> pas nécessaire
- Ne conserver que les LC démarrées avant les 2/3 de peine

```{r}

ELIG_situ_penale <- read_parquet(paste0(path,"Export/ELIG_situ_penale.parquet"))

#2182
liste_LC_deuxtiers <- ELIG_situ_penale %>%  
  filter(LEVEECR_LC==1) %>%
  filter(DT_DEBUT_DEUXTIERS <= DT_LEVEECR & DT_LEVEECR <= DT_FIN_SITU_PENALE) %>% 
  select(NM_ECROU_INIT,DT_DEUXTIERSDEPEINE,DT_LEVEECR,DT_LIBE_PREV) %>% 

    group_by(NM_ECROU_INIT) %>% 
    mutate(DT_LEVEECR_min=min(DT_LEVEECR)) %>% 
    ungroup() %>% 
    filter(DT_LEVEECR_min==DT_LEVEECR) %>% select(-DT_LEVEECR_min) %>% 

  mutate(INDIC_DEUXTIERS_APRES = if_else(DT_DEUXTIERSDEPEINE >= DT_LEVEECR, 1,0))  %>% 
  filter(INDIC_DEUXTIERS_APRES==1) %>% 
  select(NM_ECROU_INIT,DT_DEUXTIERSDEPEINE, DT_LEVEECR)

write_parquet(liste_LC_deuxtiers,paste0(path,"Export/liste_LC_deuxtiers.parquet"))

rm(ELIG_situ_penale)

```


#2. Eligibilité LSC selon AP

### Chargement table ELIG (situ penale)

```{r}

if (!exists("ELIG_situ_penale")) {
ELIG_situ_penale <- read_parquet(paste0(path,"Export/ELIG_situ_penale.parquet"))

ECROU_ELIG <- ELIG_situ_penale %>% select(NM_ECROU_INIT) %>% distinct()
}


```

### AP dans situ pénit

##### Récuperer situ penit (HORS LSC)

- On réduit aux NM_ECROU_INIT pertinents
- TOP_ECROUE ==1 : supprime les intervalles avec une libération (TOP_SORTIE_DEF ==0) et plus généralement les pas utiles 

```{r}
# SITU_PENIT --------------------------------------------------------------
T_DWH_H_SITU_PENIT <- read_parquet(paste0(path_dwh,"t_dwh_h_situ_penit.parquet"))
# table(T_DWH_H_SITU_PENIT$TOP_ECROUE,T_DWH_H_SITU_PENIT$TOP_SORTIE_DEF)

situ_penit <- ECROU_ELIG %>% 
  left_join(T_DWH_H_SITU_PENIT %>% 
      filter(TOP_ECROUE ==1) %>% 
      select(NM_ECROU_INIT,DT_DEBUT_SITU_PENIT,DT_FIN_SITU_PENIT,CD_MOTIF_HEBERGEMENT,TOP_HEBERGE,TOP_LSC, CD_TYPE_AMENAGEMENT, CD_AMENAGEMENT_PEINE, DT_DEBUT_EXEC,DT_SUSPSL,CD_STATUT_SEMI_LIBERTE, CD_CATEG_ADMIN)
          ) %>% 
  distinct() 

rm(T_DWH_H_SITU_PENIT)
rm(ECROU_ELIG)
```

Récupérer l'aménagement HORS LSC

```{r}
situ_penit_propre <- situ_penit %>% 
  # HORS LSC
  filter(TOP_LSC==0) %>% 
  # Redressement dates
  mutate_at(vars(starts_with("DT_")), as.Date) %>% 
  # Redressement aménagement de peine
  mutate(top_detention = if_else(CD_MOTIF_HEBERGEMENT %in% c('PE','PSEM','PSE','SEFIP','DDSE'),0,1),    
         AMENAGEMENT = case_when(
    top_detention==0 & CD_MOTIF_HEBERGEMENT %in% c('PSE', 'PSEM', 'SEFIP') ~ "DDSE", #PSE
    top_detention==0 & CD_MOTIF_HEBERGEMENT == 'DDSE'  ~ "DDSE",
    top_detention==0 & CD_MOTIF_HEBERGEMENT == "PE" ~ "PE_nheb",
    top_detention==0 & CD_TYPE_AMENAGEMENT %in% c('PSE', 'PSEM', 'SEFIP') ~ "DDSE", #PSE
    top_detention==0 & CD_TYPE_AMENAGEMENT == 'DDSE' ~ "DDSE",
    top_detention==0 & CD_TYPE_AMENAGEMENT == 'PE' ~ "PE_nheb",
    top_detention==1 & CD_AMENAGEMENT_PEINE == "PE" ~ "PE_heb",
    top_detention==1 & CD_AMENAGEMENT_PEINE == "SL" & (CD_STATUT_SEMI_LIBERTE == "O" | str_detect(CD_CATEG_ADMIN, "SL")) ~ "SL",
    top_detention==1 & CD_TYPE_AMENAGEMENT == "SL" & (CD_STATUT_SEMI_LIBERTE == "O" | str_detect(CD_CATEG_ADMIN, "SL")) ~ "SL"
  )) %>% 
  filter(!is.na(AMENAGEMENT)) %>% 
  # Adaptation des dates
  mutate(DT_DEBUT_AP = case_when( 
    is.na(DT_DEBUT_EXEC)|DT_DEBUT_EXEC<DT_DEBUT_SITU_PENIT ~ DT_DEBUT_SITU_PENIT,
     TRUE  ~ DT_DEBUT_EXEC),
        DT_FIN_AP = case_when(
    is.na(DT_SUSPSL)|DT_SUSPSL>DT_DEBUT_SITU_PENIT|year(DT_SUSPSL)==1900 ~ DT_FIN_SITU_PENIT,
     TRUE  ~ DT_SUSPSL)) %>% 
  # Enlever les variables inutiles
  select(-DT_DEBUT_SITU_PENIT,-DT_FIN_SITU_PENIT,-top_detention, -CD_MOTIF_HEBERGEMENT, -CD_TYPE_AMENAGEMENT, -CD_STATUT_SEMI_LIBERTE,-CD_CATEG_ADMIN,-TOP_HEBERGE) %>% 
  arrange(NM_ECROU_INIT,DT_DEBUT_AP)

rm(situ_penit)
```

##### Simplification des lignes

- récupérer date de fin de ligne précédente et comparer info
- première date AP

```{r}
situ_penit_ddbl<- situ_penit_propre %>% 
  arrange(NM_ECROU_INIT,DT_DEBUT_AP) %>% 
  group_by(NM_ECROU_INIT,AMENAGEMENT) %>% 
  mutate(DT_FIN_AP_PREV = lag(DT_FIN_AP)+1,
         MM_SITU_AP = if_else(is.na(DT_FIN_AP_PREV)|DT_FIN_AP_PREV!=DT_DEBUT_AP,1,0),
         ID_SITU_AP = cumsum(MM_SITU_AP)) %>% 
  ungroup() %>% 
  #garde qu'une ligne par enchaînement de situ pénit AP
    group_by(NM_ECROU_INIT,AMENAGEMENT,ID_SITU_AP) %>% 
    mutate(DT_FIN_AP = max(DT_FIN_AP)) %>% 
    ungroup() %>% 
      filter(MM_SITU_AP==1)

rm(situ_penit_propre)
```
##### Ab initio


```{r}
t_dwh_ecrou_init <- read_parquet(paste0(path_dwh,"t_dwh_ecrou_init.parquet")) 

t_dwh_ecrou_init <- t_dwh_ecrou_init %>% 
  select(NM_ECROU_INIT, DT_ECROU_INITIAL) %>% 
  mutate(DT_ECROU_INITIAL=as.Date(DT_ECROU_INITIAL)) %>% 
    distinct() 

situ_penit_ddbl <- situ_penit_ddbl %>% 
  # Première date d'AP
  group_by(NM_ECROU_INIT) %>% 
  mutate(DT_FIRST_AP = min(DT_DEBUT_AP)) %>% 
  ungroup() %>% 
  
  #Date ecrou initial et ab initio
  left_join(t_dwh_ecrou_init) %>% 
  mutate(INDIC_ABINITIO = if_else(time_length(difftime(DT_FIRST_AP,DT_ECROU_INITIAL), "days") <= 7, 1, 0)) 

rm(t_dwh_ecrou_init)  
```

##### Export intermédiaire
```{r}
write_parquet(situ_penit_ddbl,paste0(path,"Export/ELIG_situ_penit.parquet"))
```


#3. Eligible et AP ?

### Chargement

```{r}
if (!exists("situ_penit_ddbl")) {
    situ_penit_ddbl <- read_parquet(paste0(path,"Export/ELIG_situ_penit.parquet"))
}

if (!exists("ELIG_situ_penale")) {
ELIG_situ_penale <- read_parquet(paste0(path,"Export/ELIG_situ_penale.parquet"))

ECROU_ELIG <- ELIG_situ_penale %>% select(NM_ECROU_INIT) %>% distinct()
}

```

### Jointure des 2 situ

Organisation :
- Vérification si aménagement pour la liste des NM_ECROU_INIT concernés
- Si aménagement 
  - Soit l'aménagement est avant l'intervalle ou après l'intervalle -> pas de changement
  - S'il recoupe
    -> soit il coupe à droite ou à gauche l'intervalle
    -> soit il est intersecte l'intervalle

Nettoyage
- On supprime les dates de début postérieures à la date du jour
- On remplace les dates de fin de situ pénal postérieure à la date du jour par la date du lendemain de production

```{r}

ELIG_situ_penale_penit <- ELIG_situ_penale %>% 
  select(NM_ECROU_INIT, DT_DEBUT_DEUXTIERS, DT_FIN_SITU_PENALE)  %>% 
  left_join(situ_penit_ddbl %>% 
              select(NM_ECROU_INIT,AMENAGEMENT,DT_DEBUT_AP, DT_FIN_AP)
            ) %>% 
  ungroup() %>% 
    # Retire si AP couvre la période
  filter(is.na(AMENAGEMENT)|
        (DT_FIN_AP <= DT_DEBUT_DEUXTIERS | DT_FIN_SITU_PENALE <= DT_DEBUT_AP)| # AP avant / Après
        (DT_DEBUT_DEUXTIERS <= DT_DEBUT_AP & DT_FIN_AP <= DT_FIN_SITU_PENALE)| #intersection AP
        (DT_DEBUT_DEUXTIERS < DT_DEBUT_AP & DT_DEBUT_AP < DT_FIN_SITU_PENALE & DT_FIN_SITU_PENALE <= DT_FIN_AP)| #coupe à droite de la situ pénale
        (DT_DEBUT_AP <= DT_DEBUT_DEUXTIERS & DT_DEBUT_DEUXTIERS < DT_FIN_AP & DT_FIN_AP < DT_FIN_SITU_PENALE)) %>% # coupe à gauche de la situ pénale %within% interval(DT_DEBUT_AP, DT_FIN_AP)) %>%
  mutate(INTERSECTION = case_when(is.na(AMENAGEMENT) ~ 0,
              DT_DEBUT_DEUXTIERS <= DT_DEBUT_AP & DT_FIN_AP <= DT_FIN_SITU_PENALE ~ 1, 
              TRUE  ~ 0))

# A. la situ penit AP est comprise au sein de la situ pénale
# Duplication de la table en la recopiant en dessous d'elle-même
ELIG_intersection <- bind_rows(
  # La 1ere partie avant l'intersection
  ELIG_situ_penale_penit %>% filter(INTERSECTION==1) %>% 
  filter(DT_DEBUT_DEUXTIERS <= DT_DEBUT_AP) %>% 
  mutate(DT_DBT_ELIG_SSAP = DT_DEBUT_DEUXTIERS,
         DT_FIN_ELIG_SSAP = DT_DEBUT_AP) %>% 
    select(NM_ECROU_INIT,DT_DBT_ELIG_SSAP,DT_FIN_ELIG_SSAP), 
  # 2e partie après l'intersection
  ELIG_situ_penale_penit %>% filter(INTERSECTION==1) %>% 
  filter(DT_FIN_AP <= DT_FIN_SITU_PENALE) %>% 
  mutate(DT_DBT_ELIG_SSAP = DT_FIN_AP,
         DT_FIN_ELIG_SSAP = DT_FIN_SITU_PENALE)%>% 
    select(NM_ECROU_INIT,DT_DBT_ELIG_SSAP,DT_FIN_ELIG_SSAP)
                                ) 

# B. Les autres
ELIG_autres <- ELIG_situ_penale_penit %>% 
  filter(INTERSECTION==0) %>% 
    mutate(
    DT_DBT_ELIG_SSAP = case_when(
        is.na(AMENAGEMENT)|DT_FIN_AP < DT_DEBUT_DEUXTIERS|DT_DEBUT_AP > DT_FIN_SITU_PENALE ~ DT_DEBUT_DEUXTIERS, #pas d'AP ou pas d'influence
        DT_DEBUT_DEUXTIERS <= DT_DEBUT_AP  ~ DT_DEBUT_DEUXTIERS,
        DT_FIN_AP <= DT_FIN_SITU_PENALE  ~ DT_FIN_AP),
    
    DT_FIN_ELIG_SSAP = case_when(
    is.na(AMENAGEMENT)|DT_FIN_AP < DT_DEBUT_DEUXTIERS|DT_DEBUT_AP > DT_FIN_SITU_PENALE ~ DT_FIN_SITU_PENALE, #pas d'AP ou pas d'influence
        DT_DEBUT_DEUXTIERS <= DT_DEBUT_AP  ~ DT_DEBUT_AP,
        DT_FIN_AP <= DT_FIN_SITU_PENALE  ~ DT_FIN_SITU_PENALE)) %>% 
    select(NM_ECROU_INIT,DT_DBT_ELIG_SSAP,DT_FIN_ELIG_SSAP)

# C. On réunit les tables
ELIG_final_1 <- bind_rows(
  ELIG_intersection,
  ELIG_autres)  %>% 
  arrange(NM_ECROU_INIT,DT_DBT_ELIG_SSAP)

# D. Simplification si plusieurs dates de fin ou de début
ELIG_final <- ELIG_final_1 %>% 
  arrange(NM_ECROU_INIT,DT_DBT_ELIG_SSAP) %>% 
  group_by(NM_ECROU_INIT,DT_FIN_ELIG_SSAP) %>% 
  summarise(DT_DBT_ELIG_SSAP = max(DT_DBT_ELIG_SSAP)) %>% 
  ungroup() %>% 
  arrange(NM_ECROU_INIT,DT_DBT_ELIG_SSAP) %>% 
  group_by(NM_ECROU_INIT,DT_DBT_ELIG_SSAP) %>% 
  summarise(DT_FIN_ELIG_SSAP = min(DT_FIN_ELIG_SSAP)) %>% 
  ungroup() 



# E. Nettoyage + DT_LEVEECR
ELIG_final <- ELIG_final %>% 
  filter(DT_DBT_ELIG_SSAP < Sys.Date()) %>% 
  mutate(DT_FIN_ELIG_SSAP = if_else(DT_FIN_ELIG_SSAP >Sys.Date(),Sys.Date()+1, DT_FIN_ELIG_SSAP)) %>% 
  
  left_join(ELIG_situ_penale %>% 
      select(NM_ECROU_INIT, DT_LEVEECR) %>% 
      distinct())

rm(ELIG_situ_penale_penit,ELIG_situ_penale,ELIG_intersection,ELIG_autres,ELIG_final_1)
```
### Export final
```{r}
write_parquet(ELIG_final,paste0(path,"Export/ELIG_final.parquet"))

```
 
#4. Export des listes 

### 4.1 Eligibles n'ayant pas eu de LSC 

##### Chargement 
```{r}
if (!exists("LSC_NTZ_stats")) {
    LSC_NTZ_stats <- read_parquet(paste0(path,"Export/LSC_NTZ_stats.parquet"))
    LSC_NTZ_modele <- read_parquet(paste0(path,"Export/LSC_NTZ_modele.parquet"))
}

test <- LSC_NTZ_stats %>% select(NM_ECROU_INIT, DATELIB_LC, DECISIONAP_RED) %>% distinct()
test2 <-LSC_NTZ_modele %>% select(NM_ECROU_INIT, DATELIB_LC) %>% distinct()

if (!exists("ELIG_final")) {
ELIG_final <- read_parquet(paste0(path,"Export/ELIG_final.parquet"))
}

gc()
```

##### Retrait des LSC
- Récupère première info d'éligibilité
- Pas de LSC : ni refus du détenu, du JAP ou LSC accordée

```{r}
liste_ELIG_ssLSC <- ELIG_final %>%  
  #On enlève les éligibles avec LSC
  anti_join(LSC_NTZ_stats %>% 
              filter(DECISIONAP_RED %in% c("REF","ACC","NCONS")) %>% 
              select(NM_ECROU_INIT) %>% 
              distinct()) %>% 
  #Conserve la première info d'éligibilité
  mutate(DUREE_ELIGIBILITE =  time_length(difftime(DT_FIN_ELIG_SSAP,DT_DBT_ELIG_SSAP), "days")) %>% 
  group_by(NM_ECROU_INIT) %>% 
  summarize(DT_ELIG_LSC_INIT = min(DT_DBT_ELIG_SSAP),
            DUREE_ELIGIBILITE_TOTAL = sum(DUREE_ELIGIBILITE)) %>% 
  ungroup() 

rm(LSC_NTZ_stats,ELIG_final)
```

##### Export
```{r}
write_parquet(liste_ELIG_ssLSC,paste0(path,"Export/liste_ELIG_ssLSC.parquet"))

```


###4.2. AP 2/3 de peines

- Première date des 2/3 de peine
- N'ont pas bénéficié d'une LSC

##### Chargement
```{r}
if (!exists("situ_penit_ddbl")) {
    situ_penit_ddbl <- read_parquet(paste0(path,"Export/ELIG_situ_penit.parquet"))
}

if (!exists("ELIG_situ_penale")) {
ELIG_situ_penale <- read_parquet(paste0(path,"Export/ELIG_situ_penale.parquet"))
}

```

##### Selection

- Spell eligible LSC commence avant les 2/3 de peines
- Que AP dans situ penit hors LSC
- Que spell AP dans 2/3 de peine 
    -> démarrée avant 2/3 de peine
    -> fini après
- que premier spell si plusieurs

```{r}
liste_AP_deuxtiers <- ELIG_situ_penale %>% 
  filter(DT_DEUXTIERSDEPEINE >= DT_DEBUT_DEUXTIERS) %>% # & DT_DEUXTIERSDEPEINE <=DT_FIN_SITU_PENALE
  select(NM_ECROU_INIT, DT_DEBUT_DEUXTIERS, DT_FIN_SITU_PENALE,DT_DEUXTIERSDEPEINE)  %>% 
  
  inner_join(situ_penit_ddbl %>% 
               filter(TOP_LSC != "1") %>% 
               select(NM_ECROU_INIT,AMENAGEMENT,DT_DEBUT_AP, DT_FIN_AP) %>% 
                group_by(NM_ECROU_INIT) %>% 
                mutate(DT_DEBUT_AP_INIT = min(DT_DEBUT_AP)) %>% 
                ungroup()
            ) %>% 
  ungroup() %>% 
  filter(DT_DEBUT_AP <= DT_DEUXTIERSDEPEINE &  DT_DEUXTIERSDEPEINE <= DT_FIN_AP) %>% 
    group_by(NM_ECROU_INIT) %>% 
    mutate(DT_DEBUT_AP_min=min(DT_DEBUT_AP)) %>% 
    ungroup() %>% 
    filter(DT_DEBUT_AP_min==DT_DEBUT_AP) %>% select(-DT_DEBUT_AP_min) %>% 
  select(NM_ECROU_INIT,DT_DEUXTIERSDEPEINE,DT_DEBUT_AP_INIT, AMENAGEMENT)

write_parquet(liste_AP_deuxtiers,paste0(path,"Export/liste_AP_deuxtiers.parquet"))

rm(ELIG_situ_penale,situ_penit_ddbl)
```

###4.3 Fusion des listes

###### Chargement des tables
```{r}
liste_LC_deuxtiers <- read_parquet(paste0(path,"Export/liste_LC_deuxtiers.parquet"))
liste_ELIG_ssLSC <- read_parquet(paste0(path,"Export/liste_ELIG_ssLSC.parquet"))
liste_AP_deuxtiers <- read_parquet(paste0(path,"Export/liste_AP_deuxtiers.parquet"))
liste_LSC_NTZ_stats <- read_parquet(paste0(path,"Export/LSC_NTZ_stats.parquet")) %>% 
  filter(DECISIONAP_RED %in% c("REF","ACC","NCONS")) %>% 
              select(NM_ECROU_INIT) %>% 
              distinct()
```


###### Harmonisation et fusion
- Harmonisation des listes LC et AP
  -> Même colonnes : 
  -> Identifier si "ab initio" ou en cours de peine avec la date de mise à l'écrou

```{r}
liste_ALLAP_deuxtiers <- 
bind_rows(
  liste_LC_deuxtiers %>% 
    rename("DT_DEBUT_AP"="DT_LEVEECR") %>% 
    mutate(TYPE = "LC",
           DUREE_ELIGIBILITE_TOTAL = NA) %>% 
    select(NM_ECROU_INIT,DT_DEUXTIERSDEPEINE,TYPE,DT_DEBUT_AP),
  liste_AP_deuxtiers %>% 
    rename("DT_DEBUT_AP"="DT_DEBUT_AP_INIT") %>% 
    mutate(TYPE= AMENAGEMENT,
           DUREE_ELIGIBILITE_TOTAL = NA) %>% 
    select(NM_ECROU_INIT,DT_DEUXTIERSDEPEINE,TYPE,DT_DEBUT_AP)
          ) %>%
  left_join(t_dwh_ecrou_init) %>% 
  mutate(INDIC_ABINITIO = if_else(time_length(difftime(DT_DEBUT_AP,DT_ECROU_INITIAL), "days") <= 7, 1, 0)) %>% 
  select(-DT_ECROU_INITIAL, -DT_DEBUT_AP)
```
  
  
- Fusion avec eligibles sans LSC
- Verif que pas de NM_ECROU_INIT dans LSC
- Garde que la première

```{r}
liste_COMPAR_LSC <- 
  bind_rows(
    liste_ALLAP_deuxtiers %>% 
      rename("DATEDECISION"="DT_DEUXTIERSDEPEINE"),
    liste_ELIG_ssLSC %>% 
      rename("DATEDECISION"="DT_ELIG_LSC_INIT") %>% 
      mutate(TYPE = "ELIG_ssLSC",
             INDIC_ABINITIO = NA)
            ) %>% 
  
  anti_join(liste_LSC_NTZ_stats) %>% 

  arrange(NM_ECROU_INIT, DATEDECISION) %>%
  group_by(NM_ECROU_INIT) %>%
  slice(1) %>%
  ungroup()

write_parquet(liste_COMPAR_LSC,paste0(path,"Export/liste_COMPAR_LSC.parquet"))

rm(liste_ALLAP_deuxtiers,liste_LSC_NTZ_stats,liste_ELIG_ssLSC,liste_AP_deuxtiers,liste_LC_deuxtiers)
```


#5. Stats sur les éligibles 

- Créer une table avec toutes les combinaisons possibles d'ID et d'année -> ATTENTION à 9999 -> 2024
- Ajouter la colonne TOP qui vaut 1 si l'année est entre DBT et FIN, 0 sinon

```{r}
if (!exists("ELIG_final")) {
ELIG_final <- read_parquet(paste0(path,"Export/ELIG_final.parquet"))
}

if (!exists("LSC_NTZ_stats")) {
    LSC_NTZ_stats <- read_parquet(paste0(path,"Export/LSC_NTZ_stats.parquet"))
    LSC_NTZ_modele <- read_parquet(paste0(path,"Export/LSC_NTZ_modele.parquet"))
}
```


### Comparaison LSC et Eligible
```{r}
ELIG_ssLSC <- ELIG_final %>% select(NM_ECROU_INIT) %>% distinct() %>% 
  anti_join(LSC_NTZ_stats %>% 
              filter(DECISIONAP_RED %in% c("REF","ACC","NCONS")) %>% 
              select(NM_ECROU_INIT) %>% 
              distinct())

LSC_ssELIG <- LSC_NTZ_stats %>% 
      filter(DECISIONAP_RED %in% c("REF","ACC","NCONS")) %>% 
  mutate(ERREUR_LSC =  time_length(difftime(DATEDEBUTEXECUTION,DATEDEUXTIERSDEPEINE), "days")) %>% 
  select(NM_ECROU_INIT,ANNEE_LSC,DECISIONAP_RED, REGIME, DATEDEUXTIERSDEPEINE,ERREUR_LSC) %>% 
  distinct()%>% 
      anti_join(ELIG_final %>% select(NM_ECROU_INIT) %>% distinct() ) %>% 
    filter(!is.na(ERREUR_LSC))

summary(LSC_ssELIG)
# Utilisation de la fonction density pour calculer la densité de probabilité
d <- density(LSC_ssELIG$ERREUR_LSC)
# Utilisation de la fonction plot pour tracer la courbe de densité
ggplot(LSC_ssELIG) +
  aes(x = ERREUR_LSC) +
  geom_histogram(bins = 30L, fill = "#112446") +
  theme_classic() +
  facet_wrap(vars(DECISIONAP_RED), scales = "free") +
  xlim(-100, 100)
# Stats sur ces "erreurs"
psych::describeBy(LSC_ssELIG$ERREUR_LSC, LSC_ssELIG$DECISIONAP_RED)


LSC_ssELIG_penal <- LSC_ssELIG %>% 
  inner_join(t_dwh_h_situ_penale_copie) %>% 
  arrange(NM_ECROU_INIT,DT_DEBUT_SITU_PENALE)

LSC_ssELIG_penit <- LSC_ssELIG %>% 
  inner_join(situ_penit_ddbl)

table(LSC_ssELIG$ANNEE_LSC, LSC_ssELIG$DECISIONAP_RED)
table(LSC_ssELIG$ANNEE_LSC, LSC_ssELIG$REGIME)

```
### Réduction des spells d'éligibilité
```{r}
ELIG_stats <- ELIG_final %>% 
  mutate(ANNEE_DBT = lubridate::year(DT_DBT_ELIG_SSAP),
         ANNEE_FIN = lubridate::year(DT_FIN_ELIG_SSAP),
         ANNEE_LIB = lubridate::year(DT_LEVEECR),
         ANNEEMOIS_DBT = factor(format(DT_DBT_ELIG_SSAP, "%Y-%m")),
         ANNEEMOIS_FIN = factor(format(DT_FIN_ELIG_SSAP, "%Y-%m")),
         DELAI_INTERVAL =  time_length(difftime(DT_FIN_ELIG_SSAP,DT_DBT_ELIG_SSAP), "days")
        ) %>%
  mutate(ANNEE_FIN=if_else(ANNEE_FIN>2023,2024,ANNEE_FIN),
         ANNEEMOIS_FIN=as.factor(if_else(ANNEE_FIN>2023,'2023-12',as.character(ANNEEMOIS_FIN))),
         ) %>% 
  distinct() %>%   
    group_by(NM_ECROU_INIT) %>% 
    mutate(n_tot = n(),
           n_annee = n_distinct(ANNEE_DBT) #attention au sens, on peut avoir plusieurs début une année puis un intervalle qui couvre une longue période
           ) %>%  
  ungroup() 

summary(ELIG_stats)

```

### Stats selon les années de libération

```{r}
result_ANNEELIB <- ELIG_final %>%  
  #Libéré
  filter(!is.na(DT_LEVEECR)) %>% 

  #Conserve la dernière info d'éligibilité
  mutate(DUREE_ELIGIBILITE =  time_length(difftime(DT_FIN_ELIG_SSAP,DT_DBT_ELIG_SSAP), "days")) %>% 
  group_by(NM_ECROU_INIT) %>% 
  summarize(DT_ELIG_LSC_MAX = max(DT_FIN_ELIG_SSAP),
            DUREE_ELIGIBILITE_TOTAL = sum(DUREE_ELIGIBILITE),
            DT_LEVEECR=max(DT_LEVEECR)) %>% 
  ungroup() %>% 
  mutate(ANNEE_LEVEECR=year(DT_LEVEECR)) %>% 
  
  #Identifie les LSC
  left_join(LSC_NTZ_stats %>% 
              filter(DECISIONAP_RED %in% c("ACC")) %>% 
              select(NM_ECROU_INIT) %>% 
              mutate(LSC=1) %>% 
              distinct()) %>% 
  mutate(LSC=if_else(is.na(LSC),0,1)) %>% 
  
  #Eligible à la date de libération
  mutate(INDIC_ELIG_LIB=if_else(DT_ELIG_LSC_MAX>=DT_LEVEECR,1,0)) 

table(result_ANNEELIB$LSC,result_ANNEELIB$ANNEE_LEVEECR)

table(result_ANNEELIB[result_ANNEELIB$INDIC_ELIG_LIB==1,]$LSC,result_ANNEELIB[result_ANNEELIB$INDIC_ELIG_LIB==1,]$ANNEE_LEVEECR)


```


### Stats sur les éligibles par an
```{r}

result_ANNEE <- ELIG_final %>%
  mutate(ANNEE_DBT = lubridate::year(DT_DBT_ELIG_SSAP),
         ANNEE_FIN = lubridate::year(DT_FIN_ELIG_SSAP),
         ANNEEMOIS_DBT = factor(format(DT_DBT_ELIG_SSAP, "%Y-%m")),
         ANNEEMOIS_FIN = factor(format(DT_FIN_ELIG_SSAP, "%Y-%m")),
         DELAI_INTERVAL =  time_length(difftime(DT_FIN_ELIG_SSAP,DT_DBT_ELIG_SSAP), "days")
        ) %>%
  mutate(ANNEE_FIN=if_else(ANNEE_FIN>2023,2024,ANNEE_FIN),
         ANNEEMOIS_FIN=as.factor(if_else(ANNEE_FIN>2023,'2023-12',as.character(ANNEEMOIS_FIN))),
         ) %>% 
  distinct()

summary(result_ANNEE)
#esquisse::esquisser(result_ANNEE)
psych::describeBy(result_ANNEE$DELAI_INTERVAL, result_ANNEE$ANNEE_DBT)
# Utilisation de la fonction density pour calculer la densité de probabilité
d <- density(result_ANNEE$DELAI_INTERVAL)
# Utilisation de la fonction plot pour tracer la courbe de densité
plot(d, main = "Graphique de densité", xlab = "Variable X", xlim=c(0,500))

# Créer une table avec toutes les combinaisons possibles d'ID et d'année
result_ANNEE_all <- result_ANNEE  %>% #  filter(DATE_DBT >= as.Date("2016-01-01") & DATE_FIN <= as.Date("2017-12-31")) %>%
  select(NM_ECROU_INIT,ANNEE_DBT) %>% 
  complete(NM_ECROU_INIT, ANNEE_DBT) %>% distinct() %>% 
  rename('ANNEE'='ANNEE_DBT') %>% 
  # Ajouter la colonne TOP qui vaut 1 si l'année est entre DBT et FIN, 0 sinon
    left_join(result_ANNEE) %>% 
    filter(ANNEE >= ANNEE_DBT & ANNEE <= ANNEE_FIN) %>%
    select(-ANNEE_DBT, -ANNEE_FIN)

result_ANNEE_all %>% group_by(ANNEE) %>% summarise(ELIG=n())

LSC_NTZ_stats %>% 
              filter(DECISIONAP_RED %in% c("REF","ACC","NCONS")) %>% 
              select(NM_ECROU_INIT,ANNEE_LSC)  %>% group_by(ANNEE_LSC) %>% summarise(LSC=n())

```

